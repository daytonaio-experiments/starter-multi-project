# Simplifying Full-Stack Development with Daytona: Orchestrating Multiple Projects in One Workspace

Managing multiple codebases can be a hassle. Constantly switching between repositories, setting up environments, and keeping everything in sync takes up time and effort. Daytona’s multi-project workspace feature solves this problem by bringing everything into one place.

With Daytona, you can combine multiple repositories into a single Workspace. Whether you’re using Docker, AWS, DigitalOcean, or Fly, all your projects are deployed in the same instance or virtual machine, making it easier to work on them together.

In this blog, we’ll walk you through using this feature to run a frontend app built with Next.js and Stable Diffusion API alongside a backend app powered by Supabase and Next.js APIs, all within one Workspace. By the end of this guide, you’ll have a complete full-stack AI image generation app running and a clear understanding of how Daytona simplifies multi-repo workflows.

## Why Use Daytona?

Daytona simplifies how developers set up and manage their workspaces, whether locally or in the cloud. It removes the hassle of manual configurations and makes development faster and more efficient.

Here’s what Daytona offers:

- **Simplified Workspaces:** Set up and manage development environments easily, whether locally or remotely.
- **Automated Setup:** Automates environment setup and maintenance, so you can focus on writing code instead of troubleshooting configurations.
- **Standardized Platform:** Provides a consistent workspace, ensuring your projects work the same across different machines.
- **Remote Access:** Access your development environment from anywhere without relying on local configurations.

With Daytona, developers can spend less time setting up and more time building.

## Repositories and Tools for the Application  

This full-stack application is created using two pre-configured repositories, making it easier to set up and start working right away:

### 1. Frontend Repository

Built with **Next.js** and **v0.dev** for components, **Stable Diffusion API** for image generation, and pre-configured **Dev Container** for quick setup.

- **Setup:** Comes with a pre-configured Dev Container for quick and hassle-free setup.

- **GitHub Link:** https://github.com/daytonaio-experiments/starter-nextjs-v0

### 2. Backend Repository

Includes **Next.js** and **Supabase** for the database, and **Database.build** for schema design, all ready to use with a Dev Container for a hassle-free setup.

- **Setup:** Includes a Dev Container to simplify the environment configuration.

- **GitHub Link:** https://github.com/daytonaio-experiments/starter-nextjs-supabase

### 3. Daytona for Project Orchestration

[Daytona](https://www.daytona.io/) brings these two repositories together into a single Workspace, enabling you to work on and run the full-stack application with ease.

## Orchestrating Your Full-Stack App with Daytona: From Setup to API Integration

Now, let’s set up your full-stack AI image generator app. First, we’ll configure the database, and then we’ll use Daytona's multi-project feature to bring the frontend and backend projects together into a single workspace.

### Step 1: Setting Up Supabase to Store Images and Prompts

In this step, we’ll set up a Supabase project to create a database that will store the **images** and **prompts** generated by your AI image generation app. Supabase is an easy-to-use backend-as-a-service platform that helps you quickly set up a database, authentication, and more. Let’s walk through the process:

**1. Create a Supabase Project**

Start by setting up a Supabase project. Head over to the [Supabase documentation](https://supabase.com/docs/guides/database/overview) and follow the steps to create a new project for your application.

Once your project is created, Supabase will automatically set up a PostgreSQL database for you. Make sure to keep the details handy, as you’ll need them to connect your app later.

**2. Create the Tables to Store Images and Prompts**

Now that we have a project, let’s create the table where the generated images and user prompts will be stored. In the Supabase dashboard, navigate to the **SQL Editor** and enter the **SQL commands** to create the necessary table.

You can use the following SQL:

```sql
create table images (
  id bigint primary key generated always as identity,
  prompt text not null,
  image_base64 text not null,
  created_at timestamp with time zone default now() not null
);
```

Explanation of the table structure:

- **id:** A unique identifier for each image (auto-generated).
- **prompt:** The user’s text prompt that was used to generate the image (stored as a string).
- **image_base64:** The base64 encoded string of the generated image (to store the image data).
- **created_at:** The timestamp for when the image was created (automatically filled in by Supabase).

Once you’ve added the SQL code, click **Run** to execute it and create the table in your database.

**3. Verify the Database Table**

After running the SQL command, it’s time to check that the table was created correctly. In your Supabase dashboard, go to the **Table Editor** to confirm that the images table is visible. You should see the columns you just defined (`id`, `prompt`, `image_base64`, `created_at`).

![](/docs/assets/supabase-table-image.png)

This step ensures everything is in place and the table is ready to store data.

**4. Get Your Supabase Credentials**

To connect your app to the Supabase database, you’ll need the Project URL and API Key. These credentials allow your application to communicate with Supabase securely.

To find them, go to **Project Settings** > **API** in the Supabase dashboard. Here, you’ll see both the `Project URL` and `API Key`. Copy these values because you’ll need them to set up the connection between your backend project and Supabase.

### Step 2: Create a Single Daytona Workspace for Frontend and Backend Projects

Now that we have our Supabase database set up, it’s time to bring the frontend and backend projects together into one unified workspace using Daytona. Daytona simplifies the process of running this full-stack application by managing the environment and dependencies for both projects, so you can focus purely on writing code.

Both the frontend and backend repositories already include **pre-configured devcontainers** (in the form of `devcontainer.json` files). This means that Daytona can automatically spin up the necessary environments for both projects without requiring you to manually configure anything. With just a few simple commands, we’ll have both repositories running inside a single Daytona workspace.

Let’s go through the setup step-by-step.

**Requirements:**

Before you start, make sure you have the following:

- [Daytona](https://www.daytona.io/) installed on your system.

- Docker engine running on your machine.

- The Daytona server is running. If it’s not, start it by running `daytona serve` command.

**1. Setting Up the Workspace with Daytona**

To bring both your frontend and backend repositories into one Daytona workspace, we’ll use the `daytona create` command with `--multi-project` flag. This will link the two repositories together and set up the development environments.

Simply run the following command to set up your unified workspace:

```bash
daytona create --multi-project
```

For a detailed setup guide, check out this [documentation](https://www.daytona.io/docs/usage/workspaces/#create-a-workspace-with-multiple-projects).

![](/docs/assets/multi-project-summary-image.png)

**2. Opening the Projects in VS Code**

After successfully setting up your workspace, you can easily open both your frontend and backend projects in VS Code with the following command:

```bash
daytona code
```

**3: Adding Environment Variables**

Now that both projects are set up in your workspace, we need to configure the necessary environment variables for both projects. These variables will store sensitive information like `API keys` and `project URLs`.

In your **frontend project** (starter-nextjs-v0), add your Stable Diffusion **API key** to the `.env` file located in the root of the project:

```bash
API_KEY=STABILITY_API_KEY
```

You can get your API key by signing up for an account at [Stability AI](https://platform.stability.ai/) and following the [documentation here](https://platform.stability.ai/docs/api-reference) to obtain your key.


Now, in the **backend project** (starter-nextjs-supabase), create a `.env` file in the root of the project and add your Supabase **project URL** and Supabase **API Key**:

```bash
SUPABASE_URL="SUPABASE_PROJECT_URL"
SUPABASE_API_KEY="SUPABASE_API_KEY"
```

**4: Setting Up the Docker Network**

To enable communication between the frontend and backend containers, we need to connect them using a shared Docker network. By default, containers are isolated from each other, but creating a common network allows them to communicate and work together smoothly.

**Create a Shared Docker Network** 

Run the following command to create a Docker network named **dev-shared-network**, which will connect the frontend and backend containers:

```bash
docker network create dev-shared-network
```

**Connect the Containers to the Network**

Next, we need to link both the frontend and backend containers to the shared network we just created.

For the frontend container (specified in devcontainer.json as **frontend-container**), run:

```
docker network connect dev-shared-network frontend-container
```

For the backend container (specified in devcontainer.json as **backend-container**), run:

```
docker network connect dev-shared-network backend-container
```

By running these commands, both containers will be linked to the **dev-shared-network**, allowing them to communicate with each other.

**Verifying the Network Connection**

To verify that the containers are successfully connected to the network, you can inspect the network with this command:

```bash
docker network inspect dev-shared-network
```

Here’s what the output might look like:

```json
[
  {
    "Name": "dev-shared-network",
    "Id": "d58c4374a04326bf42bca947438a55deb388859334d9de451333404a1411a6f9",
    "Created": "2024-11-28T00:16:26.861191609+05:30",
    "Scope": "local",
    "Driver": "bridge",
    "EnableIPv6": false,
    "IPAM": {
      "Driver": "default",
      "Config": [
        {
          "Subnet": "172.18.0.0/16",
          "Gateway": "172.18.0.1"
        }
      ]
    },
    "Containers": {
      "0f41e9edccfb94221c294b1f23cbbb0e6e52ceb050373794887b134cb29eaf0a": {
        "Name": "frontend-container",
        "IPv4Address": "172.18.0.2/16"
      },
      "b7f1179d7a64d0cef8d73106759b6d4f1d7c0be9ead01279e66c24cbefe502cb": {
        "Name": "backend-container",
        "IPv4Address": "172.18.0.3/16"
      }
    }
  }
]
```

In this output, you can see that both `frontend-container` and `backend-container` are part of the `dev-shared-network` and have distinct IP addresses that allow them to communicate.

### Step 3: Adding API Endpoints for Image Storage and Retrieval from Supabase

Now that we have our frontend and backend project is set up, it's time to integrate the backend with Supabase so that we can store and retrieve prompts along with the images generated by our AI. The backend project, **starter-nextjs-supabase**, is already configured to work with Supabase, so we just need to create a couple of API endpoints to handle storing and fetching the images from the database.

In this section, we’ll walk you through adding two key API endpoints:

- **Add Image Endpoint:** This will accept a **POST** request to store an image (in base64 format) along with the prompt that generated it.
- **Get Images Endpoint:** This will accept a **GET** request to retrieve all the images stored in the database, along with their associated prompts.

**1. Creating the Add Image Endpoint**

First, let’s create an API endpoint that will handle storing images in the Supabase database. The endpoint will accept a **POST** request containing the `prompt` and the `image_base64` (the image in base64 format).

In the backend project, navigate to the **src/app/api** folder. Create a new folder named **add-image**, and inside it, create a file called `route.ts`.

Now, paste the following code into `route.ts`:

```ts
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '../../../utils/supabaseClient';

export async function POST(req: NextRequest) {
  // Parse incoming JSON request
  const { prompt, image_base64 } = await req.json();

  // Validate required fields
  if (!prompt || !image_base64) {
    return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
  }

  // Insert data into Supabase
  const { data, error } = await supabase
    .from('images')
    .insert([{ prompt, image_base64 }]);

  // Handle potential errors
  if (error) {
    return NextResponse.json({ success: false, message: 'Failed to add image', error: error.message }, { status: 500 });
  }

  // Respond with success message and inserted data 
  return NextResponse.json({ success: true, message: 'Image added successfully', data }, { status: 200 });
}
```

This endpoint will allow the frontend to store the generated image (in base64 format) and the prompt in the Supabase database.

**2. Creating the Get Images Endpoint**

Next, we’ll create an endpoint to retrieve all the images stored in the Supabase database, along with the prompts used to generate them. This will be a simple **GET** request that fetches all records from the `images` table.

In the same **src/app/api** folder, create a new folder called `get-images`, and inside it, create a file called `route.ts`.

Paste the following code into `route.ts`:

```ts
import { NextResponse } from 'next/server';
import { supabase } from '../../../utils/supabaseClient';

export async function GET() {
  const { data, error } = await supabase.from('images').select('*');

  if (error) {
    return NextResponse.json(
      { success: false, message: 'Failed to retrieve images', error: error.message },
      { status: 500 }
    );
  }

  return NextResponse.json({ success: true, message: 'Images retrieved successfully', data }, { status: 200 });
}
```

This endpoint will allow the frontend to retrieve all stored images, along with their prompts, which can be displayed in the app.

### Step 4: Connecting the Frontend with the Backend to Store and Retrieve Images

Now that the backend API is set up to handle storing and retrieving images from the Supabase database, we need to update the **frontend project** (starter-nextjs-v0) to trigger these backend APIs for storing generated images and displaying them in the history section.

**1. Create Proxy API Endpoints in the Frontend**

To allow the frontend to communicate with the backend, we need to create **proxy API endpoints** that forward requests to the backend services. This is necessary because we’re running the frontend and backend in separate containers, so we can't use **localhost**. Instead, we use the container names, such as http://backend-container:3000/api/add-image.

**Proxy Add Image Endpoint**

First, let's create a proxy endpoint that will forward the request to the backend’s `add-image` endpoint. Create a new file `/api/proxy-add-image/route.ts` and add the following code:

```ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(req: NextRequest) {
  try {
    const body = await req.json(); // Parse the request body

    const response = await fetch('http://backend-container:3000/api/add-image', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body), // Forward the body as-is
    });

    const data = await response.json();

    return NextResponse.json(data, { status: response.status }); // Return the response from the proxied request
  } catch (error) {
    console.error('Error proxying request:', error);

    if (error instanceof Error) {
      return NextResponse.json(
        { success: false, message: 'Failed to proxy request', error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json(
      { success: false, message: 'An unknown error occurred' },
      { status: 500 }
    );
  }
}
```

This endpoint will take the incoming **POST** request, forward it to the backend’s `add-image` API, and return the response back to the frontend.

**Proxy Get Images Endpoint**

Next, let’s create another proxy endpoint to fetch the images from the backend. This will allow the frontend to display all stored images.

Create a new file `/api/proxy-get-images/route.ts` and add the following code:

```ts
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // Forward the request to the backend container
    const response = await fetch('http://backend-container:3000/api/get-images', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Parse and return the response
    const data = await response.json();
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error('Error proxying request:', error);

    return NextResponse.json(
      { success: false, message: 'Failed to proxy request', error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

This endpoint will send a **GET** request to the backend’s `get-images` API to fetch all stored images and return the data to the frontend.

**2. Update the Frontend to Store and Retrieve Images**

Now, we need to integrate these proxy APIs into the frontend’s image generation and history sections.

**Update the handleGenerate Function**

In the `app/chat/page.tsx` file, we need to update the **handleGenerate** function to store the generated image and its prompt in the database after it’s created by the AI. Here’s how you can do that:

```ts
const handleGenerate = async () => {
  setIsLoading(true);
  await new Promise((resolve) => setTimeout(resolve, 2000)); // Simulate loading time

  try {
    // Call the generate-image endpoint
    const response = await fetch("/api/generate-image", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ prompt }),
    });

    const data = await response.json();

    if (response.ok) {
      const { imageUrl } = data;
      setImageUrl(imageUrl);

      // Save the generated image and prompt using the proxy API
      const saveResponse = await fetch("/api/proxy-add-image", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          prompt,
          image_base64: imageUrl.replace(/^data:image\/png;base64,/, ""), // Remove the base64 prefix
        }),
      });

      const saveResult = await saveResponse.json();

      if (!saveResponse.ok) {
        console.error("Error saving image:", saveResult.message);
      } else {
        console.log("Image saved successfully:", saveResult.data);
      }
    } else {
      console.error("Error generating image:", data.error);
    }
  } catch (error) {
    console.error("Error:", error);
  } finally {
    setIsLoading(false);
  }
};
```

In this updated function:

- After generating the image, the frontend calls the `/api/proxy-add-image` endpoint to store the generated image and the prompt in the database.

- The `imageUrl` is the base64-encoded image returned by the AI. We strip off the prefix (`data:image/png;base64,`) before sending it to the backend.

**Update the History Page**

Finally, let’s update the history page (`app/history/page.tsx`) to display all the images stored in the database.

In the `app/history/page.tsx` file, we use the `/api/proxy-get-images` endpoint to fetch and display the images.

```tsx
'use client'

import { useState, useEffect } from 'react';
import { Footer } from '../components/Footer';
import { Modal } from '../components/ImagePopUp';

export default function ImageDashboard() {
  const [images, setImages] = useState<{ id: number; url: string; prompt: string }[]>([]);
  const [selectedImage, setSelectedImage] = useState<{ id: number; url: string; prompt: string } | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchImages = async () => {
      try {
        const response = await fetch('/api/proxy-get-images');
        const data = await response.json();

        if (response.ok) {
          setImages(
            data.data.map((image: { id: number; prompt: string; image_base64: string }) => ({
              id: image.id,
              prompt: image.prompt,
              url: `data:image/png;base64,${image.image_base64}`,
            }))
          );
        } else {
          setError(data.message || 'Failed to fetch images.');
        }
      } catch (err) {
        console.error('Error fetching images:', err);
        setError('An error occurred while fetching images.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchImages();
  }, []);

  if (isLoading) {
    return (
      <div className="flex flex-col bg-black text-white pb-4 min-h-screen flex items-center justify-center">
        <p className="text-gray-400">Loading images...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col bg-black text-white pb-4 min-h-screen flex items-center justify-center">
        <p className="text-red-500">{error}</p>
      </div>
    );
  }

  return (
    <div className="flex flex-col bg-black text-white pb-4">
      <div className="min-h-screen flex flex-col bg-black text-white p-8">
        <header className="mb-8">
          <h1 className="text-3xl font-bold">Your AI Image History</h1>
          <p className="text-gray-400">Click on an image to view it in full size</p>
        </header>

        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
          {images.map((image) => (
            <div
              key={image.id}
              className="bg-gray-900 rounded-lg overflow-hidden cursor-pointer transition-transform hover:scale-105"
              onClick={() => setSelectedImage(image)}
            >
              <img src={image.url} alt={image.prompt} className="w-full h-48 object-cover" />
              <div className="p-4">
                <p className="text-sm text-gray-300 truncate">{image.prompt}</p>
              </div>
            </div>
          ))}
        </div>

        <Modal isOpen={!!selectedImage} onClose={() => setSelectedImage(null)}>
          {selectedImage && (
            <div>
              <img src={selectedImage.url} alt={selectedImage.prompt} className="w-full h-auto rounded-lg" />
              <p className="mt-4 text-center text-gray-300">{selectedImage.prompt}</p>
            </div>
          )}
        </Modal>
      </div>
      <Footer />
    </div>
  );
}
```
Here, each image is displayed as a thumbnail, and clicking on an image opens it in a modal to view it in full size.

### Step 5: Running your Full-Stack Application

Now that we've set up both the frontend and backend, it’s time to get everything running so we can see the full stack in action!

**1. Start the Backend Project (starter-nextjs-supabase)**

Navigate to the **starter-nextjs-supabase** project and run the following command in your terminal:

```bash
npm run dev
```

This will start the backend server, which will be available at `http://localhost:3000`. 

**2. Start the Frontend Project (starter-nextjs-v0)**

Now, navigate to the `starter-nextjs-v0` project and run the frontend with the following:

```bash
npm run dev
```

This will start the frontend server, and it should be accessible at `http://localhost:3001`. The frontend will interact with the backend through the proxy APIs we set up earlier, allowing you to generate images and view the image history.

### Step 6: Testing the Application

Now that everything is set up, let's test the app!

**1. Go to the Frontend App:** 

Open your browser and navigate to http://localhost:3001 where the frontend is running.

**2. Enter a Prompt**

Type a prompt (e.g., ***A beautiful sunset over the mountains***) in the input field.

**3. Generate the Image**

Click **Generate Image**. The app will process the prompt, generate the image, and save it to the database.

![sunset ai image](/docs/assets/sunset-stability-image.png)

**4. Check the History Page**

Go to the History page to see the generated image along with the prompt.

![histroy page frontend](/docs/assets/frontend-histroy-page.png)

And that's it! You've successfully tested the app and generated an image, and can now view it in your history section. 

## Conclusion

By using [Daytona](https://www.daytona.io/) to bring both the frontend and backend projects into a single workspace, we simplified managing and running our full-stack app. Daytona takes care of the environment setup and configuration, so you can focus on building features and testing without hassle.

If you run into any issues, the Daytona team is ready to help via [Slack](https://go.daytona.io/slack) or [GitHub](https://github.com/daytonaio/daytona). Now it's your turn to experiment, customize, and build something amazing. Let Daytona handle the heavy lifting while you create something impactful. Happy coding!